#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_FluxSurface

#include "Basic.hpp"

#include "BE_UnderwaterVisibility_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "BS_FluxSplashData_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "BE_SurfaceMesh_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_FluxSurface.BP_FluxSurface_C
// 0x0450 (0x06E0 - 0x0290)
class ABP_FluxSurface_C : public AActor
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x0290(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	class UMaterialBillboardComponent*            MaterialBillboard;                                 // 0x0298(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UStaticMeshComponent*                   VolumeScattering;                                  // 0x02A0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UStaticMeshComponent*                   VolumeAbsorbtion;                                  // 0x02A8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UProceduralMeshComponent*               SurfaceProceduralMesh;                             // 0x02B0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UDecalComponent*                        DecalCausticsWet;                                  // 0x02B8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UStaticMeshComponent*                   SurfaceSectionMesh;                                // 0x02C0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_FluxDataAudioComponent_C*           BP_FluxAudioComponent;                             // 0x02C8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UStaticMeshComponent*                   SurfaceOverMesh;                                   // 0x02D0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UStaticMeshComponent*                   SurfaceUnderMesh;                                  // 0x02D8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_FluxDataComponent_C*                BP_FluxDataComponent;                              // 0x02E0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UAudioComponent*                        VolumeAudio;                                       // 0x02E8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UPostProcessComponent*                  VolumePostProcess;                                 // 0x02F0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBoxComponent*                          VolumeCollision;                                   // 0x02F8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_FluxMeshGenerator_C*                BP_FluxMeshGenerator;                              // 0x0300(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x0308(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, NonTransactional, NoDestructor, HasGetValueTypeHash)
	struct FVector                                DomainSize;                                        // 0x0310(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UPDA_FluxSimulationState_C*             SimulationState;                                   // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class UPDA_FluxCoastlineState_C*              CoastlineState;                                    // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	TSoftObjectPtr<class ABP_FluxSurfaceCutMask_C> CutMaskActor;                                     // 0x0338(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash)
	class ABP_FluxOceanWave_C*                    OceanWaveActor;                                    // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash)
	TSoftObjectPtr<class AActor>                  ScenePainterActor;                                 // 0x0368(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash)
	EBE_SurfaceMesh                               SurfaceMeshMode;                                   // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ExternalMeshActor;                                 // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FTransform                             SurfaceMeshTransform;                              // 0x03A0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UMaterialInterface*                     SurfaceOverMaterial;                               // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Interp, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	class UMaterialInstanceDynamic*               SurfaceSectionInstance;                            // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UMaterialInterface*                     SurfaceUnderMaterial;                              // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class UMaterialInterface*                     SurfaceSectionMaterial;                            // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class UMaterialInterface*                     SurfaceDistantMaterial;                            // 0x0420(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	class UMaterialInterface*                     CausticsWetMaterial;                               // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	class UMaterialInterface*                     PostprocessMaterial;                               // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash)
	class UMaterialInterface*                     VolumeAbsorptionMaterial;                          // 0x0438(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class UMaterialInterface*                     VolumeScatteringMaterial;                          // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	TArray<class UMaterialInstanceDynamic*>       MaterialInstances;                                 // 0x0448(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	TArray<class UMaterialInstanceDynamic*>       InteractionInstances;                              // 0x0458(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	class UMaterialInstanceDynamic*               SurfaceOverInstance;                               // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UMaterialInstanceDynamic*               SurfaceUnderInstance;                              // 0x0470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UMaterialInstanceDynamic*               CausticsInstance;                                  // 0x0478(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UMaterialInstanceDynamic*               PostprocessInstance;                               // 0x0480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UMaterialInstanceDynamic*               VolumeAbsorptionInstance;                          // 0x0488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          GenerateProceduralMeshView;                        // 0x0490(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     GeneratedSurfaceOverMaterial;                      // 0x0498(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	uint8                                         GenerateEdgePadding;                               // 0x04A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_4A1[0x3];                                      // 0x04A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GenerateLOD;                                       // 0x04A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        AudioFalloffDistance;                              // 0x04A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                AudioExtendDistance;                               // 0x04B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class USoundBase*                             AudioAmbient;                                      // 0x04C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class UMaterialInstanceDynamic*               VolumeScatteringInstance;                          // 0x04D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<class USceneComponent*>                UnderSurfaceComponents;                            // 0x04D8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	class UMaterialInstanceDynamic*               SurfaceDistantInstance;                            // 0x04E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<class USceneComponent*>                UnderVolumeComponents;                             // 0x04F0(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	double                                        CurrentCameraBlur;                                 // 0x0500(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsCameraUnderSurface;                              // 0x0508(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          InitVolumeRendered;                                // 0x0509(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_50A[0x6];                                      // 0x050A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AStaticMeshActor*>               DistantMeshes;                                     // 0x0510(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate)
	TMap<int32, struct FBS_FluxSplashData>        InteractionSplashes;                               // 0x0520(0x0050)(Edit, BlueprintVisible, ContainsInstancedReference)
	class USceneComponent*                        CameraComponent;                                   // 0x0570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	TMap<EBE_SurfaceMesh, TSoftObjectPtr<class UStaticMesh>> SurfaceMeshes;                          // 0x0578(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	class FString                                 GeneratedMeshStats;                                // 0x05C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash)
	TMap<EBE_SurfaceMesh, TSoftObjectPtr<class UStaticMesh>> SectionMeshes;                          // 0x05D8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance)
	struct FIntVector                             WorldOriginLocation;                               // 0x0628(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_634[0x4];                                      // 0x0634(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraComponent*                      InfiniteOverPlane;                                 // 0x0638(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UNiagaraComponent*                      InfiniteUnderPlane;                                // 0x0640(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash)
	struct FVector                                ExtendVolumeSize;                                  // 0x0648(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UPDA_FluxSurfacePreset_C*               BaseColorPreset;                                   // 0x0660(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	TSoftObjectPtr<class AActor>                  SkyLight;                                          // 0x0668(0x0028)(Edit, BlueprintVisible, HasGetValueTypeHash)
	int32                                         InfiniteGridLevelsOver;                            // 0x0690(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         InfiniteGridLevelsUnder;                           // 0x0694(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	double                                        InfiniteGridMeshScale;                             // 0x0698(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UPDA_FluxSurfacePreset_C*               ShoreColorPreset;                                  // 0x06A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class UPDA_FluxSurfacePreset_C*               PainterColorPreset;                                // 0x06A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	EBE_UnderwaterVisibility                      UnderwaterVisibility;                              // 0x06B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_6B1[0x7];                                      // 0x06B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        InfiniteGridBoundsScale;                           // 0x06B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ALandscape*                             Landscape;                                         // 0x06C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TArray<class AActor*>                         GlassMeshes;                                       // 0x06C8(0x0010)(Edit, BlueprintVisible, DisableEditOnTemplate, DisableEditOnInstance)

public:
	void UserConstructionScript();
	void UpdateHeightMap(class UTexture* Value);
	void UpdateCamera(double DeltaTime);
	void SpawnSplashAtLocation(const struct FVector& Location, int32 Type);
	void SpawnSplash(const struct FVector& Location, const struct FBS_FluxSplashData& BS_FluxSplashData);
	void SetWaveTextureAndArea(class UTextureRenderTarget2D* Texture, const struct FLinearColor& Area);
	void SetWaveTexture();
	void SetWaveProfile(class UPDA_FluxWaveProfile_C* Profile);
	void SetStateHeightWetMap(class UTexture* Texture);
	void SetSimulationState(class UPDA_FluxSimulationState_C* State);
	void SetNiagaraData(class UNiagaraComponent* NiagaraSystem, bool& RequiredGround, bool& RequiredWave);
	void SetInteractionsTexture(class UTextureRenderTarget2D* Texture);
	void SetInteractionsArea(const struct FLinearColor& Area);
	void SetColorPreset(int32 Index_0, class UPDA_FluxSurfacePreset_C* Preset);
	void SetCoastlineState(class UPDA_FluxCoastlineState_C* State);
	void SetCameraUnderVisibility(bool PostProcessVolume, bool BottomSurface);
	void RemovePostprocess();
	void ReceiveTick(float DeltaSeconds);
	void ReceiveEndPlay(EEndPlayReason EndPlayReason);
	void ReceiveBeginPlay();
	void OnGlassMeshChanged();
	void OffsetWorld();
	void LoadMesh();
	void InitializeVolumes(const struct FVector& AreaSize);
	void InitializeSurfaces(const struct FVector& AreaSize);
	void InitializeStates();
	void InitializeOverlaping();
	void InitializeOvelapingEvent();
	void InitializeAllStates();
	void GetWaveTextureMaterials(TArray<class UMaterialInstanceDynamic*>* MaterialInstances_0);
	void GetSimulationState(class UPDA_FluxSimulationState_C** State);
	void GetColorPreset(int32 Index_0, class UPDA_FluxSurfacePreset_C** Preset);
	void GetCoastlineState(class UPDA_FluxCoastlineState_C** State);
	void GenerateProceduralMeshFromSimulationState();
	void GenerateMesh(class UPDA_FluxSimulationState_C* State);
	void Generate();
	void ExecuteUbergraph_BP_FluxSurface(int32 EntryPoint);
	void DetectCurrentCamera();
	void CreateMaterialsForMesh();
	void CreateMaterialsForGlass();
	void CreateMaterials();
	void CreateDynamicWaterBodyMaterial(class AActor* WaterBodyActor, class UMaterialInstanceDynamic** Material);
	void ConstructSurfaceMesh();
	void CanRenderWave(bool* CanRender);
	void CanRenderInteractions(bool* CanRender);
	void BndEvt__BP_FluxSurface_Volume_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void ApplySurfaceNiagaraData(class UNiagaraComponent* ParticleSystem, bool RequiredGround, bool RequiredWave);
	void ApplySurfaceMaterialData(const TArray<class UMaterialInstanceDynamic*>& Materials);
	void ApplySurfaceBoundsZ();
	void ApplyPainter();
	void ApplyMaterialData(TArray<class UMaterialInstanceDynamic*>& Materials);
	void ApplyMask();
	void ApplyColorProfiles();
	void ApplyColor();
	void AddToUnderSurfaceList(const class USceneComponent*& Item);

	void GetVolumeCollision(class UPrimitiveComponent** Volume) const;
	void Get_Cut_Mask(struct FVector4* Mask) const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_FluxSurface_C">();
	}
	static class ABP_FluxSurface_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_FluxSurface_C>();
	}
};
static_assert(alignof(ABP_FluxSurface_C) == 0x000010, "Wrong alignment on ABP_FluxSurface_C");
static_assert(sizeof(ABP_FluxSurface_C) == 0x0006E0, "Wrong size on ABP_FluxSurface_C");
static_assert(offsetof(ABP_FluxSurface_C, UberGraphFrame) == 0x000290, "Member 'ABP_FluxSurface_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, MaterialBillboard) == 0x000298, "Member 'ABP_FluxSurface_C::MaterialBillboard' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, VolumeScattering) == 0x0002A0, "Member 'ABP_FluxSurface_C::VolumeScattering' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, VolumeAbsorbtion) == 0x0002A8, "Member 'ABP_FluxSurface_C::VolumeAbsorbtion' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceProceduralMesh) == 0x0002B0, "Member 'ABP_FluxSurface_C::SurfaceProceduralMesh' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, DecalCausticsWet) == 0x0002B8, "Member 'ABP_FluxSurface_C::DecalCausticsWet' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceSectionMesh) == 0x0002C0, "Member 'ABP_FluxSurface_C::SurfaceSectionMesh' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, BP_FluxAudioComponent) == 0x0002C8, "Member 'ABP_FluxSurface_C::BP_FluxAudioComponent' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceOverMesh) == 0x0002D0, "Member 'ABP_FluxSurface_C::SurfaceOverMesh' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceUnderMesh) == 0x0002D8, "Member 'ABP_FluxSurface_C::SurfaceUnderMesh' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, BP_FluxDataComponent) == 0x0002E0, "Member 'ABP_FluxSurface_C::BP_FluxDataComponent' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, VolumeAudio) == 0x0002E8, "Member 'ABP_FluxSurface_C::VolumeAudio' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, VolumePostProcess) == 0x0002F0, "Member 'ABP_FluxSurface_C::VolumePostProcess' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, VolumeCollision) == 0x0002F8, "Member 'ABP_FluxSurface_C::VolumeCollision' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, BP_FluxMeshGenerator) == 0x000300, "Member 'ABP_FluxSurface_C::BP_FluxMeshGenerator' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, DefaultSceneRoot) == 0x000308, "Member 'ABP_FluxSurface_C::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, DomainSize) == 0x000310, "Member 'ABP_FluxSurface_C::DomainSize' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SimulationState) == 0x000328, "Member 'ABP_FluxSurface_C::SimulationState' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, CoastlineState) == 0x000330, "Member 'ABP_FluxSurface_C::CoastlineState' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, CutMaskActor) == 0x000338, "Member 'ABP_FluxSurface_C::CutMaskActor' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, OceanWaveActor) == 0x000360, "Member 'ABP_FluxSurface_C::OceanWaveActor' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, ScenePainterActor) == 0x000368, "Member 'ABP_FluxSurface_C::ScenePainterActor' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceMeshMode) == 0x000390, "Member 'ABP_FluxSurface_C::SurfaceMeshMode' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, ExternalMeshActor) == 0x000398, "Member 'ABP_FluxSurface_C::ExternalMeshActor' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceMeshTransform) == 0x0003A0, "Member 'ABP_FluxSurface_C::SurfaceMeshTransform' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceOverMaterial) == 0x000400, "Member 'ABP_FluxSurface_C::SurfaceOverMaterial' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceSectionInstance) == 0x000408, "Member 'ABP_FluxSurface_C::SurfaceSectionInstance' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceUnderMaterial) == 0x000410, "Member 'ABP_FluxSurface_C::SurfaceUnderMaterial' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceSectionMaterial) == 0x000418, "Member 'ABP_FluxSurface_C::SurfaceSectionMaterial' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceDistantMaterial) == 0x000420, "Member 'ABP_FluxSurface_C::SurfaceDistantMaterial' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, CausticsWetMaterial) == 0x000428, "Member 'ABP_FluxSurface_C::CausticsWetMaterial' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, PostprocessMaterial) == 0x000430, "Member 'ABP_FluxSurface_C::PostprocessMaterial' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, VolumeAbsorptionMaterial) == 0x000438, "Member 'ABP_FluxSurface_C::VolumeAbsorptionMaterial' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, VolumeScatteringMaterial) == 0x000440, "Member 'ABP_FluxSurface_C::VolumeScatteringMaterial' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, MaterialInstances) == 0x000448, "Member 'ABP_FluxSurface_C::MaterialInstances' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, InteractionInstances) == 0x000458, "Member 'ABP_FluxSurface_C::InteractionInstances' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceOverInstance) == 0x000468, "Member 'ABP_FluxSurface_C::SurfaceOverInstance' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceUnderInstance) == 0x000470, "Member 'ABP_FluxSurface_C::SurfaceUnderInstance' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, CausticsInstance) == 0x000478, "Member 'ABP_FluxSurface_C::CausticsInstance' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, PostprocessInstance) == 0x000480, "Member 'ABP_FluxSurface_C::PostprocessInstance' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, VolumeAbsorptionInstance) == 0x000488, "Member 'ABP_FluxSurface_C::VolumeAbsorptionInstance' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, GenerateProceduralMeshView) == 0x000490, "Member 'ABP_FluxSurface_C::GenerateProceduralMeshView' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, GeneratedSurfaceOverMaterial) == 0x000498, "Member 'ABP_FluxSurface_C::GeneratedSurfaceOverMaterial' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, GenerateEdgePadding) == 0x0004A0, "Member 'ABP_FluxSurface_C::GenerateEdgePadding' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, GenerateLOD) == 0x0004A4, "Member 'ABP_FluxSurface_C::GenerateLOD' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, AudioFalloffDistance) == 0x0004A8, "Member 'ABP_FluxSurface_C::AudioFalloffDistance' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, AudioExtendDistance) == 0x0004B0, "Member 'ABP_FluxSurface_C::AudioExtendDistance' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, AudioAmbient) == 0x0004C8, "Member 'ABP_FluxSurface_C::AudioAmbient' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, VolumeScatteringInstance) == 0x0004D0, "Member 'ABP_FluxSurface_C::VolumeScatteringInstance' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, UnderSurfaceComponents) == 0x0004D8, "Member 'ABP_FluxSurface_C::UnderSurfaceComponents' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceDistantInstance) == 0x0004E8, "Member 'ABP_FluxSurface_C::SurfaceDistantInstance' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, UnderVolumeComponents) == 0x0004F0, "Member 'ABP_FluxSurface_C::UnderVolumeComponents' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, CurrentCameraBlur) == 0x000500, "Member 'ABP_FluxSurface_C::CurrentCameraBlur' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, IsCameraUnderSurface) == 0x000508, "Member 'ABP_FluxSurface_C::IsCameraUnderSurface' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, InitVolumeRendered) == 0x000509, "Member 'ABP_FluxSurface_C::InitVolumeRendered' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, DistantMeshes) == 0x000510, "Member 'ABP_FluxSurface_C::DistantMeshes' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, InteractionSplashes) == 0x000520, "Member 'ABP_FluxSurface_C::InteractionSplashes' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, CameraComponent) == 0x000570, "Member 'ABP_FluxSurface_C::CameraComponent' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SurfaceMeshes) == 0x000578, "Member 'ABP_FluxSurface_C::SurfaceMeshes' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, GeneratedMeshStats) == 0x0005C8, "Member 'ABP_FluxSurface_C::GeneratedMeshStats' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SectionMeshes) == 0x0005D8, "Member 'ABP_FluxSurface_C::SectionMeshes' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, WorldOriginLocation) == 0x000628, "Member 'ABP_FluxSurface_C::WorldOriginLocation' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, InfiniteOverPlane) == 0x000638, "Member 'ABP_FluxSurface_C::InfiniteOverPlane' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, InfiniteUnderPlane) == 0x000640, "Member 'ABP_FluxSurface_C::InfiniteUnderPlane' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, ExtendVolumeSize) == 0x000648, "Member 'ABP_FluxSurface_C::ExtendVolumeSize' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, BaseColorPreset) == 0x000660, "Member 'ABP_FluxSurface_C::BaseColorPreset' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, SkyLight) == 0x000668, "Member 'ABP_FluxSurface_C::SkyLight' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, InfiniteGridLevelsOver) == 0x000690, "Member 'ABP_FluxSurface_C::InfiniteGridLevelsOver' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, InfiniteGridLevelsUnder) == 0x000694, "Member 'ABP_FluxSurface_C::InfiniteGridLevelsUnder' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, InfiniteGridMeshScale) == 0x000698, "Member 'ABP_FluxSurface_C::InfiniteGridMeshScale' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, ShoreColorPreset) == 0x0006A0, "Member 'ABP_FluxSurface_C::ShoreColorPreset' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, PainterColorPreset) == 0x0006A8, "Member 'ABP_FluxSurface_C::PainterColorPreset' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, UnderwaterVisibility) == 0x0006B0, "Member 'ABP_FluxSurface_C::UnderwaterVisibility' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, InfiniteGridBoundsScale) == 0x0006B8, "Member 'ABP_FluxSurface_C::InfiniteGridBoundsScale' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, Landscape) == 0x0006C0, "Member 'ABP_FluxSurface_C::Landscape' has a wrong offset!");
static_assert(offsetof(ABP_FluxSurface_C, GlassMeshes) == 0x0006C8, "Member 'ABP_FluxSurface_C::GlassMeshes' has a wrong offset!");

}

