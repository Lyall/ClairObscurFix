#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPI_FluxTickableEditorCallback

#include "Basic.hpp"

#include "BPI_FluxTickableEditorCallback_classes.hpp"
#include "BPI_FluxTickableEditorCallback_parameters.hpp"


namespace SDK
{

// Function BPI_FluxTickableEditorCallback.BPI_FluxTickableEditorCallback_C.UpdateModifierMaterials
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<class UMaterialInstanceDynamic*>&Materials                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    UseVelocityMap                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_FluxTickableEditorCallback_C::UpdateModifierMaterials(const TArray<class UMaterialInstanceDynamic*>& Materials, bool UseVelocityMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorCallback_C", "UpdateModifierMaterials");

	Params::BPI_FluxTickableEditorCallback_C_UpdateModifierMaterials Parms{};

	Parms.Materials = std::move(Materials);
	Parms.UseVelocityMap = UseVelocityMap;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_FluxTickableEditorCallback.BPI_FluxTickableEditorCallback_C.TogleDebugGround
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_FluxTickableEditorCallback_C::TogleDebugGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorCallback_C", "TogleDebugGround");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_FluxTickableEditorCallback.BPI_FluxTickableEditorCallback_C.ToggleUpdateSimulation
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_FluxTickableEditorCallback_C::ToggleUpdateSimulation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorCallback_C", "ToggleUpdateSimulation");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_FluxTickableEditorCallback.BPI_FluxTickableEditorCallback_C.OnEditorUpdateLoop
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_FluxTickableEditorCallback_C::OnEditorUpdateLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorCallback_C", "OnEditorUpdateLoop");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_FluxTickableEditorCallback.BPI_FluxTickableEditorCallback_C.OnEditorStopSimulation
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_FluxTickableEditorCallback_C::OnEditorStopSimulation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorCallback_C", "OnEditorStopSimulation");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_FluxTickableEditorCallback.BPI_FluxTickableEditorCallback_C.OnEditorShowSimulation
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_FluxTickableEditorCallback_C::OnEditorShowSimulation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorCallback_C", "OnEditorShowSimulation");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_FluxTickableEditorCallback.BPI_FluxTickableEditorCallback_C.OnEditorSelectionChanged
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Selected                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_FluxTickableEditorCallback_C::OnEditorSelectionChanged(bool Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorCallback_C", "OnEditorSelectionChanged");

	Params::BPI_FluxTickableEditorCallback_C_OnEditorSelectionChanged Parms{};

	Parms.Selected = Selected;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_FluxTickableEditorCallback.BPI_FluxTickableEditorCallback_C.OnEditorRestartSimulation
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_FluxTickableEditorCallback_C::OnEditorRestartSimulation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorCallback_C", "OnEditorRestartSimulation");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_FluxTickableEditorCallback.BPI_FluxTickableEditorCallback_C.OnEditorPostLoad
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_FluxTickableEditorCallback_C::OnEditorPostLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorCallback_C", "OnEditorPostLoad");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_FluxTickableEditorCallback.BPI_FluxTickableEditorCallback_C.OnEditorModifierChanged
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_FluxTickableEditorCallback_C::OnEditorModifierChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorCallback_C", "OnEditorModifierChanged");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_FluxTickableEditorCallback.BPI_FluxTickableEditorCallback_C.OnEditorIterateSimulation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Iterations                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_FluxTickableEditorCallback_C::OnEditorIterateSimulation(int32 Iterations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorCallback_C", "OnEditorIterateSimulation");

	Params::BPI_FluxTickableEditorCallback_C_OnEditorIterateSimulation Parms{};

	Parms.Iterations = Iterations;

	AsUObject()->ProcessEvent(Func, &Parms);
}

}

