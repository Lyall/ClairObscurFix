#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPI_FluxTickableEditorEvents

#include "Basic.hpp"

#include "BPI_FluxTickableEditorEvents_classes.hpp"
#include "BPI_FluxTickableEditorEvents_parameters.hpp"


namespace SDK
{

// Function BPI_FluxTickableEditorEvents.BPI_FluxTickableEditorEvents_C.UpdateLoop
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_FluxTickableEditorEvents_C::UpdateLoop(double DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorEvents_C", "UpdateLoop");

	Params::BPI_FluxTickableEditorEvents_C_UpdateLoop Parms{};

	Parms.DeltaTime = DeltaTime;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_FluxTickableEditorEvents.BPI_FluxTickableEditorEvents_C.StopSimulation
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_FluxTickableEditorEvents_C::StopSimulation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorEvents_C", "StopSimulation");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_FluxTickableEditorEvents.BPI_FluxTickableEditorEvents_C.StartSimulation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Delay                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Iterations                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_FluxTickableEditorEvents_C::StartSimulation(double Delay, int32 Iterations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorEvents_C", "StartSimulation");

	Params::BPI_FluxTickableEditorEvents_C_StartSimulation Parms{};

	Parms.Delay = Delay;
	Parms.Iterations = Iterations;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_FluxTickableEditorEvents.BPI_FluxTickableEditorEvents_C.SelectionLoop
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_FluxTickableEditorEvents_C::SelectionLoop(double DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorEvents_C", "SelectionLoop");

	Params::BPI_FluxTickableEditorEvents_C_SelectionLoop Parms{};

	Parms.DeltaTime = DeltaTime;

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function BPI_FluxTickableEditorEvents.BPI_FluxTickableEditorEvents_C.RestartSimulation
// (Public, BlueprintCallable, BlueprintEvent)

void IBPI_FluxTickableEditorEvents_C::RestartSimulation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorEvents_C", "RestartSimulation");

	AsUObject()->ProcessEvent(Func, nullptr);
}


// Function BPI_FluxTickableEditorEvents.BPI_FluxTickableEditorEvents_C.PostLoad
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Delay                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void IBPI_FluxTickableEditorEvents_C::PostLoad(double Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BPI_FluxTickableEditorEvents_C", "PostLoad");

	Params::BPI_FluxTickableEditorEvents_C_PostLoad Parms{};

	Parms.Delay = Delay;

	AsUObject()->ProcessEvent(Func, &Parms);
}

}

